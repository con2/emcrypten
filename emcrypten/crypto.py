"""
Wrappers for `cryptography` functions that encapsulate our chosen parameters for those functions.

Symmetric encryption uses Fernet.

Asymmetric encryption uses RSA with exponent 65537 and key length of 4096 bits and padding
as recommended in the `cryptography` documentation.

https://cryptography.io/en/latest/fernet.html
https://cryptography.io/en/latest/hazmat/primitives/asymmetric/rsa.html
"""


from base64 import urlsafe_b64decode, urlsafe_b64encode
from hashlib import sha256

from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import rsa, padding


RSA_EXPONENT = 65537
RSA_BITS = 4096
KEY_ENCODING = serialization.Encoding.DER
PRIVATE_KEY_FORMAT = serialization.PrivateFormat.PKCS8
PUBLIC_KEY_FORMAT = serialization.PublicFormat.PKCS1


def get_padding():
    return padding.OAEP(
        mgf=padding.MGF1(algorithm=hashes.SHA256()),
        algorithm=hashes.SHA256(),
        label=None,
    )


def generate_symmetric_key() -> bytes:
    return Fernet.generate_key()


def encrypt_symmetric(plain_bytes: bytes, key: bytes) -> bytes:
    """
    Encrypts a byte string using the given key.

    Fernet's Base64 encoding is decoded for efficient storage into PostgreSQL binary fields.

    :param plain_bytes: The value to encrypt
    :param key: A key generated using `generate_symmetric_key`
    :returns: Raw bytes of the encrypted value
    """
    return urlsafe_b64decode(Fernet(key).encrypt(plain_bytes))


def decrypt_symmetric(cipher_bytes: bytes, key: bytes) -> bytes:
    """
    Decrypts a byte string encrypted with `encrypt_symmetric`.
    """
    return Fernet(key).decrypt(urlsafe_b64encode(cipher_bytes))


def generate_asymmetric_key(private_key_password: bytes) -> (bytes, bytes):
    """
    Securely generates an asymmetric encryption key. The private key will be encrypted
    during serialization using the password provided.
    """

    private_key = rsa.generate_private_key(
        public_exponent=RSA_EXPONENT,
        key_size=RSA_BITS,
    )

    encrypted_private_key = private_key.private_bytes(
        encoding=KEY_ENCODING,
        format=PRIVATE_KEY_FORMAT,
        encryption_algorithm=serialization.BestAvailableEncryption(private_key_password),
    )

    public_key = private_key.public_key().public_bytes(
        encoding=KEY_ENCODING,
        format=PUBLIC_KEY_FORMAT,
    )

    return (encrypted_private_key, public_key)


def encrypt_asymmetric(plain_bytes: bytes, public_key: bytes) -> bytes:
    """
    Given a public key generated using `generate_asymmetric_key`, encrypts `plain_bytes` so that
    it may only be opened using the corresponding private key.
    """

    public_key = serialization.load_der_public_key(public_key)

    # RSA can only encrypt blocks of the same size as key (will be padded)
    assert 8 * len(plain_bytes) <= public_key.key_size

    return public_key.encrypt(plain_bytes, get_padding())


def decrypt_asymmetric(cipher_bytes: bytes, private_key: bytes, private_key_password: bytes) -> bytes:
    """
    Given data encrypted using `encrypt_asymmetric`, decrypts it provided that the given
    `private_key` and `private_key_password` match.
    """
    private_key = serialization.load_der_private_key(private_key, private_key_password)
    return private_key.decrypt(cipher_bytes, get_padding())


def reencrypt_private_key(private_key: bytes, old_password: bytes, new_password: bytes) -> bytes:
    """
    "Changes the password" of a private key. A copy of the private key encrypted with the new password
    is returned.
    """
    private_key = serialization.load_der_private_key(private_key, old_password)
    return private_key.private_bytes(
        encoding=KEY_ENCODING,
        format=PRIVATE_KEY_FORMAT,
        encryption_algorithm=serialization.BestAvailableEncryption(new_password),
    )


def get_public_key_fingerprint(public_key: bytes) -> bytes:
    """
    Given a public key generated by `generate_asymmetric_key`, returns its SHA256 hash as binary bytes.
    """
    return sha256(public_key).digest()


def get_public_key_fingerprint_from_private_key(private_key: bytes, private_key_password: bytes) -> bytes:
    private_key = serialization.load_der_private_key(private_key, private_key_password)
    public_key = private_key.public_key().public_bytes(
        encoding=KEY_ENCODING,
        format=PUBLIC_KEY_FORMAT,
    )

    return get_public_key_fingerprint(public_key)
